# JavaScirpt的作用域和闭包
## JS的作用域在何时确定
 此法作用域就是依赖编程时所写的代码结构确定的作用域，对比浏览器在编译阶段做的事情，我们可以发现， **词法作用域就是在编译阶段确定的** 。
## 作用域是什么
### 标识符
 在程序运行的时候，数据（字符串、对象、函数等等）都是要载入内存的。想要访问对应的内存区域，标识符就在这个时候起作用了。从这个角度看，变量名、函数名等都是标识符。
### 对标识符的操作
 看代码
 ```
 // 第一种定义了标识符`a`并把数值2赋值给了`a`这种操作有一个专门的术语叫做`LHS`
 var a = 2;

 // 第二种，var b = a ,其实对应a ,b 两个操作符是不同的操作，对b来说是一个赋值操作，这是LHS,但是对a来说却是取到a对应的值，这种操作也有一个专门的术语叫做“RHS”
 var b = a;
 ```
 对标识符来说有以下两种操作。
  > * 赋值操作（LHS）；常见的是函数定义，函数传参，变量赋值等等
  > * 取值操作（RHS）；常见包括函数调用


### 看作用域
 作用域其实就是定义了 呈现在运行期进行标识符操作的范围，对应到实际问题，就是 **函数或者变量可以在什么地方调用**。

 作用域也可以看做是一套根据名称查找变量的规则。在当前作用域中无法找到某个变量时，引擎就会在 **外层嵌套** 的作用域中继续查找，直到找到这个变量，或抵达最外层作用域（全局作用域）为止。

### JS中的作用域类型
#### 函数作用域
 函数作用域是最常见的作用域。内部函数可以调用外部函数中的变量。一层层的函数，就形成了嵌套的作用域。

 “如果在函数内部我们给一个未定义的变量赋值，这个变量会转变为一个全局变量”这句话现在可以从标识符的操作的角度来理解。
 ```
var a = 1;
function foo(){
  // b第一次出现在函数foo中
  b = a;
}
foo();
  //全局可以访问到b
console.log(b); //1
 ```
 在我们调用`foo()`时，对b其实是进行了LHS操作（取得a的值并赋值给b），b前面并不存在`var` `let` 等，因此浏览器首先在`foo()`作用域里面查找b这个标识符，结果在b里面没有找到，安装作用域的规则，浏览器会继续在`foo()`的外层作用域寻找标识符b，结果还是没有找到，说明在这次查询标识符b的范围内并不存在已经定义的b，在非严格模式下LHS操作会在可查找范围的最外层（也就是全局）定义一个b，因此b也就成了一个全局的变量了（严格模式LHS找不到返回`ReferenceError`错误）。这样那句话就可以理解了。同样值得我们注意的是对操作符进行RHS操作会出现不同的情况，无论严格或者非严格模式RHS找不到对返回`ReferenceError`错误（对RHS找到的值进行不合理的操作会返回错误`TypeError`（作用域判别成功，操作非法。））。
 > 闭包：闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意 识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿 来识别、拥抱和影响闭包的思维环境。


#### 块作用域
 除了函数作用域，JS也提供块作用域。明确一点：作用域是针对标识符来说的，块作用域吧标识符限制到`{}`中。

 ES6提供的`let`,`const`方法声明的标识符都会固定于块中。常被忽略的`try/catch`中的`catch`语句也会创建一个块作用域。

#### 改变函数作用域的方法
 词法作用域一般在代码编译阶段已经确定，不过JS也提供动态改变作用域的方法。`eval()`函数和`with`关键字。

##### `eval()`方法：
 这个方法接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。
 ```
function foo(str,a){
  eval(str);//欺骗作用域,词法阶段阶段foo()函数中并没有定义标识符，但是在函数运行阶段却临时定义了一个b；
  console.log(a,b);
}
var b = 2;
foo("var b =3;",1);//1,3
// 严格模式下，`eval()`会产生自己的作用域，无法修改所在的作用域
function foo(str){
  'use strict';
  eval(str);
  console.log(a);//ReferenceError: a is not de ned
}

foo('var a =2');
 ```
 `eval()`有时有用，但对性能消耗巨大，也可能带来安全隐患。
